#' Get back-to-back barplot for 2 conditions comparison
#'
#' @param tab_c1 barplot dataframe generated by getBarplotDF() for condition 1
#' @param tab_c2 barplot dataframe generated by getBarplotDF() for condition 1
#' @param lab_c1 label for condition 1
#' @param lab_c2 label for condition 2
#'
#' @return ggplot object
#' @importFrom tidyr pivot_longer
#' @importFrom dplyr bind_rows
getBack2BackBarplot <- function(tab_c1, tab_c2, 
                                lab_c1,
                                lab_c2){
    
    df <- merge(tab_c1, tab_c2, by = "clusters", all = TRUE)
    colnames(df) <- c("clusters", "n_paracrine_c1", "n_autocrine_c1", "n_paracrine_c2", "n_autocrine_c2")
    df[is.na(df)] <- 0
    
    difference_df <- data.frame(clusters = df$clusters)
    difference_df$tot_c1 <- df$n_paracrine_c1 + df$n_autocrine_c1
    difference_df$tot_c2 <- df$n_paracrine_c2 + df$n_autocrine_c2
    difference_df$diff_c1_c2 <- difference_df$tot_c1 - difference_df$tot_c2
    
    # From wide to long
    tab_c1 <- tidyr::pivot_longer(tab_c1,
                                  cols = c("n_paracrine","n_autocrine"), 
                                  names_to = "type", 
                                  names_prefix = "n_",
                                  values_to = "n_int")
    tab_c2 <- tidyr::pivot_longer(tab_c2, 
                                  cols = c("n_paracrine","n_autocrine"), 
                                  names_to = "type", 
                                  names_prefix = "n_",
                                  values_to = "n_int")
    # Add column for condition
    tab_c1$condition <- lab_c1
    tab_c2$condition <- lab_c2
    
    # Bind dfs
    barplot_df <- dplyr::bind_rows(tab_c1, tab_c2)
    
    cluster.colors <- scales::hue_pal(c = 80, l = 80)(
        length(unique(barplot_df$clusters)))
    
    g <- ggplot() +
        geom_bar(data = tab_c1,
                 aes(y = n_int, x = clusters,
                     fill = type,
                     color = clusters),
                 position="stack", stat="identity") +
        geom_bar(data = tab_c2,
                 aes(y = -n_int, x = clusters,
                     fill = type,
                     color = clusters),
                 position="stack", stat="identity") +
        geom_point(data = difference_df, aes(x = clusters, y = diff_c1_c2)) +
        geom_line(data = difference_df, aes(x = clusters, y = diff_c1_c2, group = 1), 
                  stat = "identity") +
        theme_minimal() +
        scale_fill_manual(values = c("#606060", "#C0C0C0")) + 
        scale_color_manual(values = cluster.colors) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), 
              text = element_text(size=20),
              strip.text = element_blank()) +
        guides(color = "none") + 
        labs(x = "Clusters", y = "# Interactions", 
             title = "Total number of interactions per cluster",
             subtitle = paste0(lab_c1, " (positive y-axis) vs ", lab_c2,
                               "  (negative y-axis)"))
    
    return(g)
    
}


#' Get radar plot of relative numbers of interactions for a certain cell type
#'
#' @param tab_c1 barplot dataframe from Viewpoint generated by getBarplotDF2() containing data for condition 1
#' @param tab_c2 barplot dataframe from Viewpoint generated by getBarplotDF2() containing data for condition 2
#' @param lab_c1 label for condition 1
#' @param lab_c2 label for condition 2
#' @param cell_name label of cell type of interest
#'
#' @return plot
#' @importFrom fmsb radarchart
#' @importFrom data.table transpose
getRadarPlot <- function(tab_c1, tab_c2, lab_c1,
                         lab_c2, cell_name){
    df <- merge(tab_c1, tab_c2, by = "Clusters", all = TRUE)
    colnames(df) <- c("Clusters", "nint_c1", "nint_c2")
    df[is.na(df)] <- 0
    
    cluster_names <- df$Clusters
    # add max and min
    max_nint <- max(df[, -1])
    df <- add_column(df, max_nint, .after = "Clusters")
    df <- add_column(df, "min_nint" = 0, .after = "max_nint")
    
    radar_df <- data.table::transpose(df[, -1])
    
    rownames(radar_df) <- c("max", "min", lab_c1, lab_c2)
    colnames(radar_df) <- cluster_names
    
    color <- c("#438ECC", "#E97778")
    
    fmsb::radarchart(
        radar_df, axistype = 1,
        # Customize the polygon
        pcol = color, 
        pfcol = scales::alpha(color, 0.5), plwd = 2, plty = 1,
        # Customize the grid
        cglcol = "grey", cglty = 1, cglwd = 0.8,
        # Customize the axis
        axislabcol = "grey30", 
        # Variable labels
        vlcex = 1.2, vlabels = colnames(radar_df),
        caxislabels = round(seq(from = 0, to = radar_df["max",1], length.out = 5)), 
        title = cell_name
    )
    legend(
        x = "bottomleft", legend = rownames(radar_df[-c(1,2),]), horiz = FALSE,
        bty = "n", pch = 20 , col = color,
        text.col = "black", cex = 1, pt.cex = 1.5
    )
    
}


#' Get table of unique int-pairs/clust-pairs couplets
#'
#' @param data_cond1 filt.data() corresponding to chosen condition 1
#' @param data_cond2 filt.data() corresponding to chosen condition 2
#' @param data_cond3 filt.data() corresponding to chosen condition 3
#' @param lab_c1 data label for condition 1
#' @param lab_c2 data label for condition 2
#' @param lab_c3 data label for condition 3
#'
#' @return modified filt.data containing only unique couplets

getDistinctCouplets <- function(data_cond1, data_cond2, data_cond3 = NULL,
                                lab_c1, lab_c2, lab_c3 = NULL){
    # Add condition column
    data_cond1$condition <- lab_c1
    data_cond2$condition <- lab_c2
    if(!is.null(data_cond3)){
        data_cond3$condition <- lab_c3
    }
    
    # Merge multiple conditions
    if(!is.null(data_cond3)){
        merged_data <- dplyr::bind_rows(data_cond1, data_cond2, data_cond3)
    } else{
        merged_data <- dplyr::bind_rows(data_cond1, data_cond2)
    }
    
    
    # Create column cluster_pair
    merged_data <- merged_data %>%
        tidyr::unite(col="cluster_pair", clustA:clustB, sep = "::", remove = FALSE)
    
    # Unique int-pairs/cluster-pairs
    distinct_pairs_clust <- merged_data %>%
        group_by(int_pair, cluster_pair) %>%
        mutate(n = n()) %>%
        filter(n == 1) 
    
    distinct_pairs_clust <- distinct_pairs_clust %>%
        arrange(int_pair) %>%
        select(-n)
    
    return(distinct_pairs_clust)
}

#' Plot dotplot containing only unique int-pair/cluster pairs with many conditions
#'
#' @param data_dotplot table with selected int_pairs for multiple conditions
#' @param clust.order how to order clusters
#' 
#' @return ggplot object

getUniqueDotplot <- function(data_dotplot, clust.order){
    
    data_dotplot$groups_x <- factor(data_dotplot$clustA, levels = clust.order)
    
    g <- ggplot(data_dotplot, aes(x = int_pair, y = cluster_pair)) +
        geom_point(aes(color = condition, size=4)) + 
        theme_minimal() +
        scale_color_manual(values = c("#438ECC", "#E97778", "#00BA38")) + 
        facet_grid(groups_x ~ ., scales = "free", space = "free") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
              text = element_text(size=20),
              strip.text.y = element_blank(),
              strip.text.x = element_text(angle = 0)) +
        guides(size = "none") + 
        labs(x = "Int-pairs", y = "Cluster-pairs")
    return(g)
}


#' Get Pie Chart of unique couplets 
#'
#' @param data_dotplot same data used to generate dotplot
#'
#' @return pie chart

getPieChart <- function(data_dotplot) {
    data <- data_dotplot %>%
        group_by(condition) %>%
        summarise(value = n())
    
    # Compute the position of labels
    data <- data %>% 
        arrange(desc(condition)) %>%
        mutate(prop = value / sum(data$value) *100) %>%
        mutate(ypos = cumsum(prop)- 0.5*prop ) %>%
        mutate(perc = paste(round(prop, digits = 0), "%", sep = " "))
    
    # Basic pie chart
    g <- ggplot(data, aes(x="", y=prop, fill=condition)) +
        geom_bar(stat="identity", width=1, color="white") +
        coord_polar("y", start=0) +
        theme_void() + 
        geom_text(aes(y = ypos, label = perc), color = "white", size=8) +
        scale_fill_manual(values = c("#438ECC", "#E97778", "#00BA38")) +
        theme(text = element_text(size=20)) 
    return(g)
}
