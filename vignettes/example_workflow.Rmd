---
title: "InterCellar workflow example"
author: "Marta Interlandi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{InterCellar workflow example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(InterCellar)
library(dplyr)
library(tibble)
library(umap)
library(ggplot2)
source("../R/fct_gene_verse.R")
source("../R/app_config.R")
source("../R/fct_cluster_verse.R")
source("../R/fct_function_verse.R")
source("../R/fct_int_pair_modules.R")

```

## Data Upload from supported tools
Here we upload pre-computed output data from CPDB v2.

```{r upload}
folder <- "/marta_home/RB1-8_out/"
input.data <- read.CPDBv2(folder)


# # Get cluster names
# cluster.list <- getClusterNames(input.data)
# # assign a color to each cluster
# cluster.colors <- hue_pal(c = 80, l = 80)(length(names(cluster.list)))
# names(cluster.colors) <- names(cluster.list)
```

## Gene-verse

```{r cfmigo}

gene.table <- getGeneTable(input.data)


```

## Function-verse: annotation


```{r func-verse, warning=FALSE}
# Gene Ontology
GO_annotation <- annotateGO(input_select_ensembl = "102", 
                            input_go_evidence_exclude = NULL,
                            input_go_sources_checkbox = c("biological_process", 
                                                          "cellular_component", 
                                                          "molecular_function"),
                            input.data)


# Pathways
selected.db <- c("biocarta","kegg", "nci", "panther","pharmgkb", "reactome")
pathways_annotation <- annotatePathways(selected.db, input.data)

# Combine annotation in one dataframe
combined_annotations <- combineAnnotations(GO_annotation, pathways_annotation)

# Get binary matrix of int-pairs by functions
intPairs_func_mat <- buildPairsbyFunctionMatrix(combined_annotations)

# Get ranked terms
rank.terms <- getRankedTerms(combined_annotations, gene.table)
```

## Analysis of intPair Modules


```{r ipModules}
# Choose cluster viewpoint and flow
sub.input.data <- getIntFlow(vp = "10", input.data, flow = "directed_out")

# Subset int pairs by function matrix on specific int pairs
sub_intPairs_func_mat <- subsetFuncMatBYFlow(intPairs_func_mat, sub.input.data)

# Plot dendrogram of int-pair modules
intPairs.dendro <- dendroIntPairModules(sub_intPairs_func_mat, seed = 123)

# Predict best number of clusters by elbow method
elbow_plot <- factoextra::fviz_nbclust(intPairs.dendro$umap[, c("UMAP_1", "UMAP_2")], 
                               factoextra::hcut, method = "wss",
                               k.max = ifelse(nrow(intPairs.dendro$umap) > 10, 
                                              20,
                                              nrow(intPairs.dendro$umap) - 1)) 


elbow_x <- round(elbowPoint(as.numeric(elbow_plot$data$clusters), 
                       elbow_plot$data$y)$x)
elbow_plot + 
        geom_vline(xintercept = elbow_x, linetype = 2, colour = "steelblue") +
        ggtitle("Optimal number of Modules: Elbow plot") +
        xlab("Number of Modules")

# silhouette
factoextra::fviz_nbclust(intPairs.dendro$umap[, c("UMAP_1", "UMAP_2")],
                                 factoextra::hcut, method = "silhouette",
                                 k.max = ifelse(nrow(intPairs.dendro$umap) > 10, 
                                                20,
                                                nrow(intPairs.dendro$umap) - 1)) +
          ggtitle("Optimal number of Modules: average silhouette") +
          xlab("Number of Modules")


gpModules_assign <- dendextend::cutree(intPairs.dendro$h_clust, 
             k = 1, 
             order_clusters_as_data = FALSE)

d <- as.dendrogram(intPairs.dendro$h_clust)
d <- dendextend::color_branches(d, 
                                k=elbow_x, 
                                groupLabels = TRUE) %>%
  dendextend::set("labels", 
                  rep("", times = 
                        length(intPairs.dendro$h_clust$labels)))

plot(d, 
           horiz = TRUE, 
           main="Dendrogram of Int-pairs", 
           family = "sans", 
           cex.main = 1.3)

ipm_colors <- colorspace::rainbow_hcl(elbow_x)

library(plotly)
getUMAPipModules(intPairs.dendro, 
                 gpModules_assign, 
                 gene.table,
                 ipm_colors,
                 "ipM_col")


selected.data <- sub.input.data %>%
        filter(int_pair %in% names(gpModules_assign)[
          gpModules_assign == as.numeric(1)])

# Permutation test to get significant functional terms for all int-pair modules
significantFunc <- getSignificantFunctions(sub_intPairs_func_mat, 
                              gpModules_assign,
                              rank.terms,
                              0.05)
```


