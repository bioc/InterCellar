---
title: "InterCellar workflow example"
author: "Marta Interlandi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{InterCellar workflow example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(InterCellar)
library(dplyr)
library(tibble)
library(umap)
library(ggplot2)
library(plotly)
library(data.table)
library(graphite)
source("../R/fct_gene_verse.R")
source("../R/app_config.R")
source("../R/fct_cluster_verse.R")
source("../R/fct_function_verse.R")
source("../R/fct_int_pair_modules.R")

```

## Data Upload from supported tools
Here we upload pre-computed output data from CPDB v2.

```{r upload}
#folder <- "/marta_home/InterCellar-docs/validation_data/covid/cpdb/MODERATE_out/"
folder <- "/marta_home/RB1-8_out/"
input.data <- read.CPDBv2(folder)


# Get cluster names
cluster.list <- getClusterNames(input.data)
# assign a color to each cluster
cluster.colors <- scales::hue_pal(c = 80, l = 80)(length(names(cluster.list)))
names(cluster.colors) <- names(cluster.list)
cl <- cluster.list[[17]]
para <- input.data %>%
  filter(clustA == cl | clustB == cl) %>%
  filter(!(clustA == cl & clustB == cl))
auto <- input.data %>%
  filter(clustA == cl & clustB == cl)

bar.data <- data.frame(Clusters = names(cluster.list), Num_int = 0)
for(c in names(cluster.list)){
  if(c == cl){
    bar.data$Num_int[bar.data$Clusters == c] <- nrow(auto)
  } else {
    bar.data$Num_int[bar.data$Clusters == c] <- sum(para$clustA == c) +
      sum(para$clustB == c)
  }
  
}

bar.data$Clusters <- factor(bar.data$Clusters, levels = names(cluster.list))

fig <- plot_ly(bar.data, 
                       x = ~Clusters, y = ~Num_int, type = "bar",
               marker = list(color = cluster.colors))
fig <- fig %>%
  add_annotations(text = ~Num_int)
fig <- fig %>% layout(title = paste0("Number of Interactions for Cluster ", cl),
                      xaxis = list(title = "Clusters"),
                      yaxis = list(title = "# Interactions"))
fig <- fig %>% config(modeBarButtonsToRemove = c(
                        'sendDataToCloud', 'autoScale2d', 'resetScale2d', 
                        'hoverClosestCartesian', 'hoverCompareCartesian',
                        'zoom2d','pan2d','select2d','lasso2d'
                      ))
fig

```

## Gene-verse

```{r cfmigo}

gene.table <- getGeneTable(input.data)


```

## Function-verse: annotation


```{r func-verse, warning=FALSE}
# Gene Ontology
GO_annotation <- annotateGO(input_select_ensembl = "102", 
                            input_go_evidence_exclude = NULL,
                            input_go_sources_checkbox = c("biological_process", 
                                                          "cellular_component", 
                                                          "molecular_function"),
                            input.data)


# Pathways
selected.db <- c("biocarta","kegg", "nci", "panther","pharmgkb", "reactome")
pathways_annotation <- annotatePathways(selected.db, input.data)

# Combine annotation in one dataframe
combined_annotations <- combineAnnotations(GO_annotation, pathways_annotation)
#combined_annotations <- GO_annotation
# Get binary matrix of int-pairs by functions
intPairs_func_mat <- buildPairsbyFunctionMatrix(combined_annotations)

# Get ranked terms
rank.terms <- getRankedTerms(combined_annotations, gene.table)


### Sunburst


func_selected <- "death receptor signalling"
int_p_fun <- as.character(rank.terms$int_pair_list[rank.terms$functional_term == func_selected])
int_p_fun <- unlist(strsplit(int_p_fun, split=","))
      
      
sel.data <- input.data %>%
        filter(int_pair %in% int_p_fun)

cluster.list <- getClusterNames(input.data)
# assign a color to each cluster 
cluster.colors <- scales::hue_pal(c = 80, l = 80)(length(names(cluster.list)))
names(cluster.colors) <- names(cluster.list)
      
getSunburst(sel.data, func_selected, int_p_fun, cluster.colors)
```

## Analysis of intPair Modules


```{r ipModules}
# Choose cluster viewpoint and flow
sub.input.data <- getIntFlow(vp = "0", input.data, flow = "directed_out")

# Subset int pairs by function matrix on specific int pairs
sub_intPairs_func_mat <- subsetFuncMatBYFlow(intPairs_func_mat, sub.input.data)

# Plot dendrogram of int-pair modules
intPairs.dendro <- dendroIntPairModules(sub_intPairs_func_mat, seed = 123)

# Predict best number of clusters by elbow method
elbow_plot <- factoextra::fviz_nbclust(intPairs.dendro$umap[, c("UMAP_1", "UMAP_2")], 
                               factoextra::hcut, method = "wss",
                               k.max = ifelse(nrow(intPairs.dendro$umap) > 10, 
                                              20,
                                              nrow(intPairs.dendro$umap) - 1)) 


elbow_x <- round(elbowPoint(as.numeric(elbow_plot$data$clusters), 
                       elbow_plot$data$y)$x)
elbow_plot + 
        geom_vline(xintercept = elbow_x, linetype = 2, colour = "steelblue") +
        ggtitle("Optimal number of Modules: Elbow plot") +
        xlab("Number of Modules")

# silhouette
factoextra::fviz_nbclust(intPairs.dendro$umap[, c("UMAP_1", "UMAP_2")],
                                 factoextra::hcut, method = "silhouette",
                                 k.max = ifelse(nrow(intPairs.dendro$umap) > 10, 
                                                20,
                                                nrow(intPairs.dendro$umap) - 1)) +
          ggtitle("Optimal number of Modules: average silhouette") +
          xlab("Number of Modules")


gpModules_assign <- dendextend::cutree(intPairs.dendro$h_clust, 
             k = elbow_x, 
             order_clusters_as_data = FALSE)

d <- as.dendrogram(intPairs.dendro$h_clust)
d <- dendextend::color_branches(d, 
                                k=elbow_x, 
                                groupLabels = TRUE) %>%
  dendextend::set("labels", 
                  rep("", times = 
                        length(intPairs.dendro$h_clust$labels)))

plot(d, 
           horiz = TRUE, 
           main="Dendrogram of Int-pairs", 
           family = "sans", 
           cex.main = 1.3)

ipm_colors <- colorspace::rainbow_hcl(elbow_x)

library(plotly)
getUMAPipModules(intPairs.dendro, 
                 gpModules_assign, 
                 gene.table,
                 ipm_colors,
                 "ipM_col")

## next to circle
selected.data <- sub.input.data %>%
        filter(int_pair %in% names(gpModules_assign)[
          gpModules_assign == as.numeric(4)])

# Permutation test to get significant functional terms for all int-pair modules
significantFunc <- getSignificantFunctions(sub_intPairs_func_mat, 
                              gpModules_assign,
                              rank.terms,
                              0.05)


if(!is.null(significantFunc) & nrow(significantFunc) > 0){
  sign_table <- significantFunc %>%
    filter(int_pairModule == as.integer(4)) %>%
    arrange(`pvalue`)
} else {
  sign_table <- data.table()
}
        
      
 
if(!is.null(significantFunc) & nrow(sign_table) > 0){
  occurTab <- getOccurrenceTab4wordcloud(significantFunc,
                             4,
                             gpModules_assign,
                             sub_intPairs_func_mat)
} else{occurTab <- NULL }

  
```

# Circle plot


```{r vnfgio}
cluster.list <- getClusterNames(input.data)
# assign a color to each cluster 
cluster.colors <- scales::hue_pal(c = 80, l = 80)(length(names(cluster.list)))
names(cluster.colors) <- names(cluster.list)
cluster_colors <- cluster.colors  
library(circlize)    
circlePlot(selected.data, 
           cluster_colors = cluster.colors, 
           ipm_color = ipm_colors[1],
           int_flow = "directed_out",
           link.color = input_link_col)

data <- selected.data

cell_types <- unique(c(data$clustA, data$clustB))
    # Abbreviate long names for int-pairs
    data$int_pair <- gsub("beta", "B", data$int_pair)
    data$int_pair <- gsub("inhibitor", "inh", data$int_pair)
    data$int_pair <- gsub("receptor", "rec", data$int_pair)
    partnerA <- unlist(sapply(strsplit(data$int_pair, " & "), function(x) x[1]))
    partnerB <- unlist(sapply(strsplit(data$int_pair, " & "), function(x) x[2]))
    
    genes <- c(structure(partnerA, names = data$clustA), 
               structure(partnerB, names = data$clustB))
    genes <- genes[!duplicated(paste(names(genes), genes))]
    genes <- genes[order(names(genes))]
    
    
    
    if(length(cell_types)!=1){
        gap.degree <- do.call("c", lapply(table(names(genes)), 
                                          function(i) c(rep(1, i-1), 8)))
    }else{
        gap.degree <- do.call("c", lapply(table(names(genes)), 
                                          function(i) c(rep(1, i))))
    }
    
    # parameters
    if(int_flow == "undirected"){
        directional <- 0
        direction.type <- "diffHeight"
    } else{
        directional <- 1
        direction.type <- c("diffHeight", "arrows")
    }
    
    track.height.genes <- ifelse(max(nchar(c(partnerA, partnerB))) >= 10, 
                                 0.25, 
                                 0.2)
    cex.genes <- 0.9
    
    df <- data.frame(from = paste(data$clustA,partnerA), 
                     to = paste(data$clustB,partnerB), 
                     stringsAsFactors = FALSE)
    
    if(link.color == "ipm"){
      col <- NULL
    } else {
      # scale avg scores between -2 and 2
        scaled_scores <- scales::rescale(data$score, to = c(-2,2))
        col_fun <- circlize::colorRamp2(c(-2,0,2), 
                                        c("gray88", "gray70", "black"))
        col <- col_fun(scaled_scores)
        lgd_links <- ComplexHeatmap::Legend(at = c(-2, -1, 0, 1, 2), 
                                            col_fun = col_fun, 
                                            title_position = "topleft", 
                                            title = "Scaled Int Score")
    }
    
    
    circos.par(gap.degree = gap.degree)
    
    chordDiagram(df, order=paste(names(genes),genes),
                 grid.col = ipm_color, 
                 col = col,
                 transparency = 0.2, 
                 directional = directional, 
                 direction.type = direction.type,
                 link.arr.type = "big.arrow", 
                 annotationTrack = "grid", 
                 preAllocateTracks = list(
                     list(track.height = uh(1.2,'mm')), 
                     list(track.height = track.height.genes)),  
                 annotationTrackHeight = c(0.01,0.01))
    
    
    
    
    circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
        sector.index = genes[get.cell.meta.data("sector.numeric.index")]
        circos.text(CELL_META$xcenter, 
                    CELL_META$cell.ylim[1], 
                    sector.index, 
                    col = "black", 
                    cex = cex.genes, 
                    adj = c(0, 0.5), 
                    facing = 'clockwise', 
                    niceFacing = TRUE)
    }, bg.border = NA)
    
    
    for(c in unique(names(genes))) {
        gene = as.character(genes[names(genes) == c])
        highlight.sector(sector.index = paste(c,gene), 
                         track.index = 1, 
                         col = ifelse(length(cluster_colors)==1,
                                      cluster_colors,
                                      cluster_colors[c]), 
                         text = c, 
                         text.vjust = '0.4cm', 
                         niceFacing = TRUE, 
                         lwd=1,
                         facing = "bending.inside")
    }
    
    if(link.color != "ipm"){
        ComplexHeatmap::draw(lgd_links, 
                             x = grid::unit(1, "npc"), 
                             y = grid::unit(1, "npc"),
                             just = c("right", "top"))
    }
    
    circos.clear()
    
    


```